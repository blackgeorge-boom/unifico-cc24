diff --git a/.gitignore b/.gitignore
index 47f13648..6c0fde17 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,3 +4,28 @@ cscope.out
 binutils-2.32.tar.bz2
 patches/llvm/llvm-3.7.1_old.patch
 patches/llvm/clang-3.7.1_old.patch
+
+###############################################
+
+# Swap
+[._]*.s[a-v][a-z]
+[._]*.sw[a-p]
+[._]s[a-rt-v][a-z]
+[._]ss[a-gi-z]
+[._]sw[a-p]
+
+# Session
+Session.vim
+
+# Temporary
+.netrwhist
+*~
+# Auto-generated tag files
+tags
+# Persistent undo
+[._]*.un~
+
+build_x86-64
+build_aarch64
+toolchain_x86-64
+toolchain_aarch64
diff --git a/lib/musl-1.1.18/Makefile b/lib/musl-1.1.18/Makefile
index 2f43e6d2..6afccd6e 100644
--- a/lib/musl-1.1.18/Makefile
+++ b/lib/musl-1.1.18/Makefile
@@ -120,10 +120,12 @@ obj/src/internal/version.o obj/src/internal/version.lo: obj/src/internal/version
 
 obj/crt/rcrt1.o obj/ldso/dlstart.lo obj/ldso/dynlink.lo: $(srcdir)/src/internal/dynlink.h $(srcdir)/arch/$(ARCH)/reloc.h
 
-obj/crt/crt1.o obj/crt/scrt1.o obj/crt/rcrt1.o obj/ldso/dlstart.lo: $(srcdir)/arch/$(ARCH)/crt_arch.h
+obj/crt/crt1.o obj/crt/Scrt1.o obj/crt/rcrt1.o obj/ldso/dlstart.lo: $(srcdir)/arch/$(ARCH)/crt_arch.h
 
 obj/crt/rcrt1.o: $(srcdir)/ldso/dlstart.c
 
+obj/crt/Scrt1.o: $(srcdir)/crt/crt1.c
+
 obj/crt/Scrt1.o obj/crt/rcrt1.o: CFLAGS_ALL += -fPIC
 
 obj/crt/$(ARCH)/crti.o: $(srcdir)/crt/$(ARCH)/crti.s
diff --git a/lib/musl-1.1.18/arch/aarch64/crt_arch.h b/lib/musl-1.1.18/arch/aarch64/crt_arch.h
index b64fb3dd..4b5e4638 100644
--- a/lib/musl-1.1.18/arch/aarch64/crt_arch.h
+++ b/lib/musl-1.1.18/arch/aarch64/crt_arch.h
@@ -1,3 +1,7 @@
+
+/* Original version by the musl authors */
+/* Current version by Antonio Barbalace, Stevens 2019 */
+
 __asm__(
 ".text \n"
 ".global " START "\n"
@@ -13,3 +17,57 @@ START ":\n"
 "	and sp, x0, #-16\n"
 "	b " START "_c\n"
 );
+
+#define STACK_RELOC_USE_MMAP 1
+
+/* TODO copy more than a byte at the time */
+#define __memcpy_nostack(dest, src, n) \
+	({ unsigned long retval =-1; \
+	__asm__ volatile(".weak __memcpy_nostack \n" \
+		".weak __memcpy_nostack_exit \n" \
+		".weak __memcpy_nostack_copy \n" \
+		"__memcpy_nostack:" \
+		"mov x4, %1 \n\t" \
+		"cmp %2, x4 \n\t" \
+		"b.le __memcpy_nostack_exit \n" \
+		"__memcpy_nostack_copy:" \
+		"ldrb w5, [%4, x4] \n\t" \
+		"strb w5, [%3, x4] \n\t" \
+		"add x4, x4, #0x1 \n\t" \
+		"cmp %2, x4 \n\t" \
+		"b.gt __memcpy_nostack_copy \n" \
+		"__memcpy_nostack_exit:" \
+		"mov %0, x4 \n\t" \
+		: "=r" (retval) \
+		: "I" (0), "r" (n), \
+		  "r" (dest), "r" (src) \
+		: "x5", "x4", "memory"); \
+	retval; })
+
+#define my_memcpy_nostack(dest, src, n) \
+	({ unsigned long retval =-1; \
+	__asm__ volatile(".weak __memcpy_nostack_boom \n" \
+		".weak __memcpy_nostack_boom_exit \n" \
+		".weak __memcpy_nostack_boom_copy \n" \
+		"__memcpy_nostack_boom:" \
+		"mov x4, %1 \n\t" \
+		"cmp %2, x4 \n\t" \
+		"b.le __memcpy_nostack_boom_exit \n" \
+		"__memcpy_nostack_boom_copy:" \
+		"ldrb w5, [%4, x4] \n\t" \
+		"strb w5, [%3, x4] \n\t" \
+		"add x4, x4, #0x1 \n\t" \
+		"cmp %2, x4 \n\t" \
+		"b.gt __memcpy_nostack_boom_copy \n" \
+		"__memcpy_nostack_boom_exit:" \
+		"mov %0, x4 \n\t" \
+		: "=r" (retval) \
+		: "I" (0), "r" (n), \
+		  "r" (dest), "r" (src) \
+		: "x5", "x4", "memory"); \
+	retval; })
+
+/* comment the following to disable relocation before libc start */
+#define STACK_RELOC
+#define STACK_RELOC_MOVE_VDSO
+#define STACK_RELOC_PROTECT
diff --git a/lib/musl-1.1.18/arch/aarch64/stack_arch.h b/lib/musl-1.1.18/arch/aarch64/stack_arch.h
new file mode 100644
index 00000000..4b818ef8
--- /dev/null
+++ b/lib/musl-1.1.18/arch/aarch64/stack_arch.h
@@ -0,0 +1,40 @@
+
+/* Original version by the musl authors */
+/* Current version by Antonio Barbalace, Stevens 2019 */
+
+#define arch_stack_get() \
+	({ unsigned long stack_ptr =-1; \
+	__asm__ volatile ("mov %0, sp\n\t" \
+		: "=r" (stack_ptr) \
+		: : "memory"); \
+	stack_ptr; })
+
+/* stack relocation configuration parameters */
+
+#define STACK_MB           (1024*1024)
+#define STACK_SIZE         (16*STACK_MB)
+#define STACK_END_ADDR     (0x800000000000)
+#define STACK_START_ADDR   (STACK_END_ADDR - STACK_SIZE)
+#define STACK_PAGE_SIZE    (4096)
+#define STACK_MAPPED_PAGES (32)
+
+#define STACK_RELOC_PAGE_ALIGN 5
+#define STACK_RELOC_OFFSET 0x00
+
+/* stack relocation arch dep macros */
+
+#define arch_stack_switch(stack_top, stack_offset) \
+	({ __asm__ volatile("sub %1, %0, %1 \n\t" \
+			"mov sp, %1 \n\t" \
+			: :"r" (stack_top), "r" (stack_offset) \
+			: "memory"); })
+
+/* TODO maybe move the following */
+
+//applies to linux only
+
+#define arch_vvar_get_pagesz() (STACK_PAGE_SIZE *1)
+
+// per arch/platform (wasn't able to find this anywhere else in the code)
+
+#define arch_vaddr_max() (0x1000000000000)
diff --git a/lib/musl-1.1.18/arch/x86_64/crt_arch.h b/lib/musl-1.1.18/arch/x86_64/crt_arch.h
index 3eec61bd..9915a4dc 100644
--- a/lib/musl-1.1.18/arch/x86_64/crt_arch.h
+++ b/lib/musl-1.1.18/arch/x86_64/crt_arch.h
@@ -1,3 +1,7 @@
+
+/* Original version by the musl authors */
+/* Current version by Antonio Barbalace, Nikos, The University of Edinburgh 2021 */
+
 __asm__(
 ".text \n"
 ".global " START " \n"
@@ -10,3 +14,70 @@ START ": \n"
 "	andq $-16,%rsp \n"
 "	call " START "_c \n"
 );
+
+/* TODO copy more than a byte at the time */
+#define __memcpy_nostack(dest, src, n) \
+	({ unsigned long retval =-1; \
+	__asm__ volatile(".weak __memcpy_nostack \n" \
+		".weak __memcpy_nostack_error \n" \
+		".weak __memcpy_nostack_exit \n" \
+		".weak __memcpy_nostack_copy \n" \
+		"__memcpy_nostack:" \
+		"cmp %4, %3; \n\t" \
+		"jg __memcpy_nostack_error; \n" \
+		"push %%r8; \n\t" \
+		"push %%r9; \n\t" \
+		"movq %1, %%r8; \n\t" \
+		"cmp %%r8, %2; \n\t" \
+		"jle __memcpy_nostack_exit; \n" \
+		"__memcpy_nostack_copy:" \
+		"movb (%4, %%r8, 1), %%r9b; \n\t" \
+		"movb %%r9b, (%3, %%r8, 1); \n\t" \
+		"inc %%r8; \n\t" \
+		"cmp %%r8, %2; \n\t" \
+		"jg __memcpy_nostack_copy; \n" \
+		"__memcpy_nostack_exit:" \
+		"movq %%r8, %0; \n\t" \
+		"pop %%r9; \n\t" \
+		"pop %%r8; \n\t" \
+		"__memcpy_nostack_error: \n\t" \
+		: "=r" (retval) \
+		: "I" (0), "r" (n), \
+		  "r" (dest), "r" (src) \
+		: "r9", "r8", "memory"); \
+	retval; })
+
+#define my_memcpy_nostack(dest, src, n) \
+	({ unsigned long retval =-1; \
+	__asm__ volatile(".weak my_memcpy_nostack \n" \
+		".weak my_memcpy_nostack_error \n" \
+		".weak my_memcpy_nostack_exit \n" \
+		".weak my_memcpy_nostack_copy \n" \
+		"my_memcpy_nostack:" \
+		"cmp %4, %3; \n\t" \
+		"jg my_memcpy_nostack_error; \n" \
+		"push %%r8; \n\t" \
+		"push %%r9; \n\t" \
+		"movq %1, %%r8; \n\t" \
+		"cmp %%r8, %2; \n\t" \
+		"jle my_memcpy_nostack_exit; \n" \
+		"my_memcpy_nostack_copy:" \
+		"movb (%4, %%r8, 1), %%r9b; \n\t" \
+		"movb %%r9b, (%3, %%r8, 1); \n\t" \
+		"inc %%r8; \n\t" \
+		"cmp %%r8, %2; \n\t" \
+		"jg my_memcpy_nostack_copy; \n" \
+		"my_memcpy_nostack_exit:" \
+		"movq %%r8, %0; \n\t" \
+		"pop %%r9; \n\t" \
+		"pop %%r8; \n\t" \
+		"my_memcpy_nostack_error: \n\t" \
+		: "=r" (retval) \
+		: "I" (0), "r" (n), \
+		  "r" (dest), "r" (src) \
+		: "r9", "r8", "memory"); \
+	retval; })
+
+/* comment the following to disable relocation before libc start */
+#define STACK_RELOC
+//in x86_64 we don't move VVAR and VDSO, at least for the moment
diff --git a/lib/musl-1.1.18/crt/crt1.c b/lib/musl-1.1.18/crt/crt1.c
index af02af94..83d85fb8 100644
--- a/lib/musl-1.1.18/crt/crt1.c
+++ b/lib/musl-1.1.18/crt/crt1.c
@@ -1,18 +1,376 @@
+
+/* Original version by the musl authors */
+/* Current version by Antonio Barbalace, Stevens 2019 */
+
+/* The current version supports aarch64 stack relocation, but can compile
+ * on any architecture. Support for stack relocation on other architecture is
+ * future work. A couple of heurisitcs are used in order to keep code compact.
+ * It also relocate the [vdso] and [var], it protects the upper memory so 
+ * malloc cannot use it to allocate anything.
+ */
+
 #include <features.h>
+#include "libc.h"
 
 #define START "_start"
 
 #include "crt_arch.h"
 
+
+#ifdef STACK_RELOC
+#define _GNU_SOURCE
+#include "stack_arch.h"
+#include <string.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include "syscall.h"
+#include <sys/prctl.h>
+#include <elf.h>
+
+#define STACK_RELOC_ALIGN 1
+
+#if ULONG_MAX == 0xffffffff
+typedef Elf32_auxv_t Auxv;
+typedef Elf32_Ehdr Ehdr;
+#else
+typedef Elf64_auxv_t Auxv;
+typedef Elf64_Ehdr Ehdr;
+#endif
+
+#define memlng_nostack(iter, start, end, value) \
+	({for (iter = start; iter <= end; iter++) \
+		if (*(unsigned long*)iter == value) { \
+			break; \
+		}})
+#endif /* STACK_RELOC */
+
+
 int main();
-void _init() __attribute__((weak));
-void _fini() __attribute__((weak));
+void _init() __attribute((weak));
+void _fini() __attribute((weak));
 _Noreturn int __libc_start_main(int (*)(), int, char **,
 	void (*)(), void(*)(), void(*)());
 
+
+#ifdef STACK_RELOC_DEBUG
+static inline char *_itoa_b16(char *p, unsigned long x)
+{
+	p += (sizeof(unsigned long)*2) +1 +1;
+	*--p = 0;
+	*--p = '\n';
+	do {
+		char c = x % 16;
+		*--p = (c < 10) ? ('0' + c) : ('a' + c -10);
+		x /= 16;
+	} while (x);
+	return p;
+}
+static inline char *_itoa_b10(char *p, long x)
+{
+	char sign =0;
+        p += 20 +1 +1;
+	*--p = 0;
+	*--p = '\n';
+	if (x < 0) {
+		x *= -1;
+		sign =1;
+	}
+	do {
+		*--p = '0'+ x % 10;
+		x /= 10;
+		} while (x);
+	if (sign)
+		*--p = '-';
+	return p;
+}
+#endif /* STACK_RELOC_DEBUG */
+
+// The stack including aux, env, arg are built by 
+// https://elixir.bootlin.com/linux/latest/C/ident/create_elf_tables
+
 void _start_c(long *p)
 {
-	int argc = p[0];
-	char **argv = (void *)(p+1);
+	register int argc = p[0];
+	register char **argv = (void *)(p+1);
+
+#ifdef STACK_RELOC
+	/* stack relocation code */
+	register char **envp = argv+argc+1;
+	Auxv *auxv; 
+	int i, copied =-1, total_size =-1; //TODO convert total_size to stack_size
+	long stack_ptr =-1, stack_addr =-1, frame_size=-1; //stack_ret=-1,
+	register long max; long vvar_base =0, vdso_size =0;
+#define max_size(aaa) (max - ((unsigned long)(aaa)))
+	Ehdr *sysinfo_ehdr;
+
+	/* ARCH getting the the current stack pointer */
+	stack_ptr = arch_stack_get();
+
+	/* check if relocation is not needed. This may happen when the current
+	 * stack is below the requested stack address.
+	 */
+	if ( STACK_START_ADDR > (unsigned long) stack_ptr)
+		goto _abort_relocation;
+//TODO cross check this for x86 seems wrong
+    
+	/* getting the current dimension of the stack, using heuristics */
+	for (i=0; i<argc; i++) {
+		if (max < (long)argv[i])
+			max = (long)argv[i];
+	}
+	for (i=0; envp[i]; i++) {
+		if (max < (long)envp[i])
+			max = (long)envp[i];
+	}
+	auxv = (Auxv *)(&envp[i+1]);
+	for (i=0; (auxv[i].a_type != AT_NULL); i++) {
+		if (max < (long)auxv[i].a_un.a_val)
+			max = (long) auxv[i].a_un.a_val;
+		
+		/* look for VDSO information */
+		if ( (auxv[i].a_type == AT_SYSINFO_EHDR) ) /* TODO maybe consider AT_SYSINFO as well */
+			sysinfo_ehdr = (Ehdr*)auxv[i].a_un.a_val;
+
+		/* check if we need to abort relocation, for example in case of dynamic 
+		* linking. The key heuristic is to check if the text section is above
+		* the new stack address -- as we don't relocate the text section, we 
+		* need to abort.
+		*/
+		if ( (auxv[i].a_type == AT_ENTRY) &&
+				(auxv[i].a_un.a_val >= STACK_END_ADDR) )
+			goto _abort_relocation;
+	}
+	/* NOTE above we may had to add the size of the variable to max, but at the moment it works */
+	
+	/* align max address, highest virtual address */
+	max = (max & ~(STACK_PAGE_SIZE -1)) + STACK_PAGE_SIZE; 
+
+	/* expected total mapped size in [stack], can be overestimated */
+	total_size = STACK_PAGE_SIZE * 
+		(STACK_MAPPED_PAGES + (max_size(stack_ptr)/STACK_PAGE_SIZE) +1);
+
+	/* size of the current stack, based on argc position, other methods based
+	 * on GCC's __builtin_* do not work on all architectures, therefore this seems
+	 * the most reliable solution
+	 */
+	frame_size = (unsigned long)p - stack_ptr;
+	
+#if 0
+	/* calculate the size of the first frame by looking at the return address of the current frame that can be obtained with a builtin */
+	stack_ret = (unsigned long)__builtin_return_address(0); // get the address to be matched 
+	memlng_nostack(stack_addr, stack_ptr, max, stack_ret);
+	if (stack_addr != max)
+		frame_size = stack_addr -stack_ptr;
+#endif	
+/*	__asm__ ("nop \n\t mov %0, %%rax \n\t mov %1, %%rbx \n\t mov %2, %%rcx \n\t mov %3, %%rdx \n\t nop \n\t": 
+	: "r" ((long)max), "r" ((long)max_size(stack_ptr)), "r" ((long)total_size), "r" ((long)frame_size)
+	: "rax", "rbx", "rcx", "rdx", "memory" );
+*/
+
+#ifdef STACK_RELOC_MOVE_VDSO
+	/* if VDSO is mapped in, let's move it firstly */
+	if (sysinfo_ehdr) {
+		/* VDSO: need to look up the size in the phdr and align it */
+		Elf64_Phdr *ph = (void *)((char *)sysinfo_ehdr + sysinfo_ehdr->e_phoff);
+		size_t base=-1, end =-1;
+		for (i=0; i<sysinfo_ehdr->e_phnum; i++, ph=(void *)((char *)ph+sysinfo_ehdr->e_phentsize)) {
+			/* so far, kernel version 5.15 there is only one PT_LOAD, this doesn't support more than one */
+			if (ph->p_type == PT_LOAD) {
+				base = (size_t)sysinfo_ehdr + ph->p_offset - ph->p_vaddr;
+				end = base + ph->p_memsz;
+				if (end & (STACK_PAGE_SIZE -1))
+					end = (end & ~(STACK_PAGE_SIZE -1)) + STACK_PAGE_SIZE;
+			}
+		}
+		if (!base || !end)
+			goto _malformed_vdso;
+
+		/* VVAR: it is before the VDSO, get the size by using a macro */
+		vvar_base = base - arch_vvar_get_pagesz();
+
+		/* remap VVAR and VDSO together at the end of the rebuilt address space */
+		stack_addr = __syscall(SYS_mremap, vvar_base, (base - vvar_base), (base - vvar_base), (MREMAP_FIXED | MREMAP_MAYMOVE), STACK_END_ADDR - (end- vvar_base));
+		if ( ((unsigned long) stack_addr) > -4096UL) {
+			i =1; goto _error;
+		}
+		stack_addr = __syscall(SYS_mremap, base, (end - base), (end - base), (MREMAP_FIXED | MREMAP_MAYMOVE), STACK_END_ADDR - (end - base));
+		if ( ((unsigned long) stack_addr) > -4096UL) {
+			i =2; goto _error;
+		}
+
+		/* update max, size, total size */
+		vdso_size = (end - vvar_base);
+    }
+_malformed_vdso:
+
+#endif /* STAC_RELOC_MOVE_VDSO */
+
+/*
+TODO in x86_64 need to move the VDSO and VVAR at the very end of the addr space and move the stack down a page (this code can be integrated with the code below -- for the moment we skipped this code
+NOTE the code below is not working, mremap doesn't allow moving to an overlapping area, and allows shrinking only at the end of the memory area (not at beginnning)
+//#ifdef x86
+stack_addr = _syscall(SYS_mremap, (max - total_size), total_size, total_size, (MREMAP_FIXED | MREMAP_MAYMOVE), STACK_END_ADDR - vdso_size - total_size);
+	if ( ((unsigned long) stack_addr) > -4096UL) {
+			i =2; goto _error;
+	}
+//#endif x86
+*/
+
+	/* if the stack is already ending at the right addr, skip this */
+	if (STACK_END_ADDR == max)
+		goto _finalize;
+	
+#if STACK_RELOC_USE_MMAP
+    /* allocate the memory to where to move the stack */
+
+#ifdef SYS_mmap2
+    stack_addr = (void*) __syscall(SYS_mmap2, STACK_START_ADDR - vdso_size, STACK_SIZE, PROT_READ|PROT_WRITE, (MAP_PRIVATE|MAP_ANON|MAP_FIXED), -1, 0);
+#else /* SYS_mmap2 */
+    stack_addr = (void*) __syscall(SYS_mmap, STACK_START_ADDR - vdso_size, STACK_SIZE, PROT_READ|PROT_WRITE, (MAP_PRIVATE|MAP_ANON|MAP_FIXED), -1, 0);
+#endif /* !SYS_mmap2 */
+	if ( ((unsigned long) stack_addr) > -4096UL) {
+		i =3; goto _error;
+	}
+	memset(stack_addr, STACK_SIZE, 0);
+#endif /* STACK_RELOC_USE_MMAP */
+    
+	/* rewrite pointers for the new stack */
+	for (i=0; i<argc; i++)
+		argv[i] = (void*) (STACK_END_ADDR - vdso_size - (max - (unsigned long) argv[i])); 
+	for (i=0; envp[i]; i++)
+		envp[i] = (void*) (STACK_END_ADDR - vdso_size - (max - (unsigned long) envp[i]));
+	for (i=0; (auxv[i].a_type != AT_NULL); i++)
+		switch (auxv[i].a_type) {
+		case AT_PHDR: case AT_BASE: case AT_ENTRY:
+		case AT_PLATFORM: case AT_BASE_PLATFORM:
+		case AT_EXECFN: case AT_RANDOM: 
+			/* check if it is != 0 and greater than the new stack end addr */
+			if (auxv[i].a_un.a_val > STACK_END_ADDR)
+				auxv[i].a_un.a_val = STACK_END_ADDR - vdso_size - (max - auxv[i].a_un.a_val);
+
+		/* we don't do VDSO relocation for now (TODO fix when we do VDSO relocation) */
+		case AT_SYSINFO: case AT_SYSINFO_EHDR:
+			if (vdso_size && auxv[i].a_un.a_val)
+				auxv[i].a_un.a_val = STACK_END_ADDR - vdso_size + arch_vvar_get_pagesz();
+		/* all others handled by the kernel */
+		case AT_HWCAP: case AT_PAGESZ: case AT_CLKTCK: case AT_PHENT:
+		case AT_PHNUM: case AT_FLAGS: case AT_UID: case AT_EUID:
+		case AT_GID: case AT_EGID: case AT_SECURE: case AT_EXECFD:
+		case AT_HWCAP2:
+			break;
+		}
+	/* update pointers with the new address */
+	argv = (void*) (STACK_END_ADDR - vdso_size - ((unsigned long)max - (unsigned long) argv));
+	envp = (void*) (STACK_END_ADDR - vdso_size - ((unsigned long)max - (unsigned long) envp));
+	auxv = (void*) (STACK_END_ADDR - vdso_size - ((unsigned long)max - (unsigned long) auxv)); // i includes the number of auxvs
+
+#if STACK_RELOC_USE_MMAP
+	/* ARCH copy of the stack */ //TODO can we use SYS_mremap instead?
+	copied = __memcpy_nostack((STACK_END_ADDR - vdso_size - max_size(stack_ptr)), stack_ptr, max_size(stack_ptr)); // only needed on arm
+	//copied = __memcpy_nostack(STACK_END_ADDR - vdso_size - total_size, stack_ptr, total_size); //TODO
+	if (copied != max_size(stack_ptr)) {
+		i = 4; goto _error;
+	}
+#else /* STACK_RELOC_USE_MMAP */
+__retry_mremap:
+	/* try mremap */
+	stack_addr = __syscall(SYS_mremap, (max - total_size), total_size, total_size, (MREMAP_FIXED | MREMAP_MAYMOVE), STACK_END_ADDR - vdso_size - total_size); // total_size must be page-aligned
+	if ( ((unsigned long) stack_addr) > -4096UL) {
+		/*
+		 * Here we use another pseudo heuristic from the Linux kernel.
+		 * When execve the kernel mm_init a stack of one page, then 
+		 * in setup_arg_pages it extends it, the extension is 32 pages
+		 * that takes it to 33, however, sometimes is 34 (on aarch64 at 
+		 * least). Setting ulimit may also end up in a smaller stack. We
+		 * try to guess the size here.
+		 */
+		if (total_size > max_size(stack_ptr)) {
+			total_size -= STACK_PAGE_SIZE;
+			goto __retry_mremap;
+		}
+		i =4; goto _error;
+	}
+#endif /* !STACK_RELOC_USE_MMAP */
+
+	/* tells to the kernel where is the stack and the env/aux variables
+	 * requires root or
+	 * http://yhbt.net/lore/all/1392387209-330-1-git-send-email-avagin@openvz.org/T/
+	 */
+	__syscall(SYS_prctl, PR_SET_MM, PR_SET_MM_START_STACK, (STACK_END_ADDR -vdso_size - max_size(stack_ptr)), 0, 0); //TODO
+	__syscall(SYS_prctl, PR_SET_MM, PR_SET_MM_ARG_START, argv[0], 0, 0);
+	__syscall(SYS_prctl, PR_SET_MM, PR_SET_MM_ARG_END,   envp[0], 0, 0);
+	__syscall(SYS_prctl, PR_SET_MM, PR_SET_MM_ENV_START, envp[0], 0, 0);	
+	__syscall(SYS_prctl, PR_SET_MM, PR_SET_MM_ENV_END,   STACK_END_ADDR -vdso_size, 0, 0);                            
+	__syscall(SYS_prctl, PR_SET_MM, PR_SET_MM_AUXV,      &auxv[0], i*sizeof(Auxv), 0);
+
+_finalize:
+#ifdef STACK_RELOC_ALIGN
+	/* fail silently if frame_size was not found before */
+	if (frame_size != -1) { // Needed for both
+		/* ARCH copy of the stack */ 
+		copied = my_memcpy_nostack((STACK_END_ADDR - 
+						((STACK_RELOC_PAGE_ALIGN*STACK_PAGE_SIZE) + STACK_RELOC_OFFSET)),// should we add -vdso???
+						(STACK_END_ADDR - vdso_size - max_size(stack_ptr)), 
+							  (long)frame_size);
+		if (copied != frame_size) {
+			i =5; goto _error;
+		}
+	}
+	/* ARCH stack switch */
+	arch_stack_switch(STACK_END_ADDR, (long)((STACK_RELOC_PAGE_ALIGN*STACK_PAGE_SIZE) +STACK_RELOC_OFFSET));
+	//arch_stack_switch(STACK_END_ADDR - vdso_size, (long)max_size(stack_ptr)); //TODO
+#else
+	/* ARCH stack switch */
+	arch_stack_switch(STACK_END_ADDR -vdso_size, (long)max_size(stack_ptr));
+#endif /* STACK_RELOC_ALIGN */
+	
+#ifdef STACK_RELOC_PROTECT
+	/* mmap protect upper area */
+	__syscall(SYS_mmap, STACK_END_ADDR, arch_vaddr_max() - STACK_END_ADDR, 0, (MAP_PRIVATE|MAP_ANON|MAP_FIXED), -1, 0);
+#endif /* STACK_RELOC_PROTECT */ 
+	
+#if STACK_RELOC_USE_MMAP
+	/* unmap previous stack */
+	__syscall(SYS_munmap, (max - total_size), total_size);
+#endif /* STACK_RELOC_USE_MMAP */
+	
+	/* WARNING here local variables may not work */
+	
+_abort_relocation:
+#endif /* STACK_RELOC */
+
+	/* now continue to normal startup */
 	__libc_start_main(main, argc, argv, _init, _fini, 0);
+
+#ifdef STACK_RELOC
+	/* we should reach here only in case of errors */
+_error:
+{
+	char serror [] = "crt1.c: _start_c ERROR 0\n";
+	char verror [22];
+	serror[23] += i;
+	__syscall(SYS_write, 2, serror, strlen(serror));
+
+#ifdef STACK_RELOC_DEBUG
+	memset(verror, '0', sizeof(unsigned long)*2 +1);
+	_itoa_b16(verror, (unsigned long) max);
+	__syscall(SYS_write, 2, verror, strlen(verror));
+
+	memset(verror, '0', sizeof(unsigned long)*2 +1);
+	_itoa_b16(verror, (unsigned long) total_size);
+	__syscall(SYS_write, 2, verror, strlen(verror));
+
+	memset(verror, '0', 20);
+	_itoa_b10(verror, (long) stack_addr);
+	__syscall(SYS_write, 2, verror, strlen(verror));
+
+	while(1){}; //debugging trap
+#endif /* STACK_RELOC_DEBUG */
+}
+    /* from src/exit/_Exit.c */
+    //int ec =1;
+    __syscall(SYS_exit_group, 1); //ec);
+    for (;;) __syscall(SYS_exit, 1); //ec);
+#endif /* STACK_RELOC */
 }
+ 
diff --git a/lib/musl-1.1.18/install_musl.sh b/lib/musl-1.1.18/install_musl.sh
new file mode 100755
index 00000000..5f9cca22
--- /dev/null
+++ b/lib/musl-1.1.18/install_musl.sh
@@ -0,0 +1,28 @@
+#!/bin/bash
+
+#MUSL_SRC=~/musl-stack-reloc
+MUSL_SRC=~/popcorn-compiler/lib/musl-1.1.18
+
+TOOLCHAIN_NAME=llvm-9
+DESTINATION_DIR=~/musl-toolchains/${TOOLCHAIN_NAME}
+X86_TOOLCHAIN_DIR=${DESTINATION_DIR}/x86-64
+ARM_TOOLCHAIN_DIR=${DESTINATION_DIR}/aarch64
+
+LLVM_TOOLCHAIN=/home/nikos/llvm-9/toolchain
+CFLAGS="-popcorn-alignment -ffunction-sections -fdata-sections -fomit-frame-pointer"
+#CFLAGS=""
+
+cd ${MUSL_SRC}
+
+rm -rf build_aarch64 build_x86-64
+mkdir -p build_x86-64 build_aarch64 ${X86_TOOLCHAIN_DIR} ${ARM_TOOLCHAIN_DIR} 
+
+cd build_x86-64
+../configure --prefix=${X86_TOOLCHAIN_DIR} --target=x86_64-linux-gnu --enable-optimize --enable-debug --enable-warnings --enable-wrapper=all --disable-shared CC=${LLVM_TOOLCHAIN}/bin/clang CFLAGS="-target x86_64-linux-gnu ${CFLAGS}" KERVER=POPCORN_5_2
+make -j16
+make install
+
+cd ../build_aarch64
+../configure --prefix=${ARM_TOOLCHAIN_DIR} --target=aarch64-linux-gnu --enable-optimize --enable-debug --enable-warnings --enable-wrapper=all --disable-shared CC=${LLVM_TOOLCHAIN}/bin/clang CFLAGS="-target aarch64-linux-gnu ${CFLAGS}" KERVER=POPCORN_5_2
+make -j16
+make install
diff --git a/lib/musl-1.1.18/src/ldso/aarch64/tlsdesc.s b/lib/musl-1.1.18/src/ldso/aarch64/tlsdesc.s
index ba28ec50..5f3621d0 100644
--- a/lib/musl-1.1.18/src/ldso/aarch64/tlsdesc.s
+++ b/lib/musl-1.1.18/src/ldso/aarch64/tlsdesc.s
@@ -45,16 +45,11 @@ __tlsdesc_dynamic:
 	ldp x1,x2,[sp],#32
 	ret
 
-	// save all registers __tls_get_new may clobber
+	// save all registers __tls_get_new may clobber TODO: removed some regs, but should fix the frame size also 
 	// update sp in two steps because offset must be in [-512,509]
 1:	stp x29,x30,[sp,#-160]!
 	stp x5,x6,[sp,#16]
 	stp x7,x8,[sp,#32]
-	stp x9,x10,[sp,#48]
-	stp x11,x12,[sp,#64]
-	stp x13,x14,[sp,#80]
-	stp x15,x16,[sp,#96]
-	stp x17,x18,[sp,#112]
 	stp q0,q1,[sp,#128]
 	stp q2,q3,[sp,#-480]!
 	stp q4,q5,[sp,#32]
@@ -90,11 +85,6 @@ __tlsdesc_dynamic:
 	ldp q2,q3,[sp],#480
 	ldp x5,x6,[sp,#16]
 	ldp x7,x8,[sp,#32]
-	ldp x9,x10,[sp,#48]
-	ldp x11,x12,[sp,#64]
-	ldp x13,x14,[sp,#80]
-	ldp x15,x16,[sp,#96]
-	ldp x17,x18,[sp,#112]
 	ldp q0,q1,[sp,#128]
 	ldp x29,x30,[sp],#160
 	b 2b
diff --git a/lib/musl-1.1.18/src/setjmp/aarch64/longjmp.s b/lib/musl-1.1.18/src/setjmp/aarch64/longjmp.s
index 3e60cb6b..e05c41ef 100644
--- a/lib/musl-1.1.18/src/setjmp/aarch64/longjmp.s
+++ b/lib/musl-1.1.18/src/setjmp/aarch64/longjmp.s
@@ -1,29 +1,18 @@
-/* Pierre: these 3 symbols will be very probably placed at the same address,
- * put them into a section with a single name, and make sure we to give the 
- * same name for each architecture
- */
-
-.section .text.longjmp, "ax"
 .global _longjmp
 .global longjmp
 .type _longjmp,%function
 .type longjmp,%function
-.align 4
 _longjmp:
 longjmp:
 	// IHI0055B_aapcs64.pdf 5.1.1, 5.1.2 callee saved registers
 	ldp x19, x20, [x0,#0]
-	ldp x21, x22, [x0,#16]
-	ldp x23, x24, [x0,#32]
-	ldp x25, x26, [x0,#48]
-	ldp x27, x28, [x0,#64]
-	ldp x29, x30, [x0,#80]
-	ldr x2, [x0,#104]
+	ldp x29, x30, [x0,#16]
+	ldr x2, [x0,#40]
 	mov sp, x2
-	ldp d8 , d9, [x0,#112]
-	ldp d10, d11, [x0,#128]
-	ldp d12, d13, [x0,#144]
-	ldp d14, d15, [x0,#160]
+	ldp d8 , d9, [x0,#48]
+	ldp d10, d11, [x0,#64]
+	ldp d12, d13, [x0,#80]
+	ldp d14, d15, [x0,#96]
 
 	mov x0, x1
 	cbnz x1, 1f
diff --git a/lib/musl-1.1.18/src/setjmp/aarch64/setjmp.s b/lib/musl-1.1.18/src/setjmp/aarch64/setjmp.s
index 7483ac2a..b8bc22d0 100644
--- a/lib/musl-1.1.18/src/setjmp/aarch64/setjmp.s
+++ b/lib/musl-1.1.18/src/setjmp/aarch64/setjmp.s
@@ -1,28 +1,20 @@
-/* Pierre: cf setjmp/aarch64/longjmp.s */
-
-.section .text.setjmp, "ax"
 .global __setjmp
 .global _setjmp
 .global setjmp
 .type __setjmp,@function
 .type _setjmp,@function
 .type setjmp,@function
-.align 4
 __setjmp:
 _setjmp:
 setjmp:
 	// IHI0055B_aapcs64.pdf 5.1.1, 5.1.2 callee saved registers
 	stp x19, x20, [x0,#0]
-	stp x21, x22, [x0,#16]
-	stp x23, x24, [x0,#32]
-	stp x25, x26, [x0,#48]
-	stp x27, x28, [x0,#64]
-	stp x29, x30, [x0,#80]
+	stp x29, x30, [x0,#16]
 	mov x2, sp
-	str x2, [x0,#104]
-	stp  d8,  d9, [x0,#112]
-	stp d10, d11, [x0,#128]
-	stp d12, d13, [x0,#144]
-	stp d14, d15, [x0,#160]
+	str x2, [x0,#40]
+	stp  d8,  d9, [x0,#48]
+	stp d10, d11, [x0,#64]
+	stp d12, d13, [x0,#80]
+	stp d14, d15, [x0,#96]
 	mov x0, #0
 	ret
diff --git a/lib/musl-1.1.18/test-stack-reloc/auxv.h b/lib/musl-1.1.18/test-stack-reloc/auxv.h
new file mode 100644
index 00000000..45975ad6
--- /dev/null
+++ b/lib/musl-1.1.18/test-stack-reloc/auxv.h
@@ -0,0 +1,16 @@
+
+/* Antonio Barbalace, Stevens 2019 */
+
+char * at_desc[] = { "AT_NULL", "AT_IGNORE", "AT_EXECFD", "AT_PHDR",
+    "AT_PHENT", "AT_PHNUM", "AT_PAGESZ", "AT_BASE", 
+    "AT_FLAGS", "AT_ENTRY", "AT_NOTELF", "AT_UID", 
+    "AT_EUID", "AT_GID", "AT_EGID", "AT_PLATFORM", 
+    "AT_HWCAP", "AT_CLKTCK", "AT_FPUCW", "AT_DCACHEBSIZE", 
+    "AT_ICACHEBSIZE", "AT_UCACHEBSIZE", "AT_IGNOREPPC", "AT_SECURE",
+    "AT_BASE_PLATFORM", "AT_RANDOM", "AT_HWCAP2", "AT_?", 
+    "AT_?", "AT_?", "AT_?", "AT_EXECFN", 
+    "AT_SYSINFO", "AT_SYSINFO_EHDR", "AT_L1I_CACHESHAPE", "AT_L1D_CACHESHAPE", 
+    "AT_L2_CACHESHAPE", "AT_L3_CACHESHAPE", "AT_?", "AT_?", 
+    "AT_L1I_CACHESIZE", "AT_L1I_CACHEGEOMETRY", "AT_L1D_CACHESIZE", "AT_L1D_CACHEGEOMETRY",
+    "AT_L2_CACHESIZE", "AT_L2_CACHEGEOMETRY", "AT_L3_CACHESIZE", "AT_L3_CACHEGEOMETRY", 
+    "AT_?", "AT_?", "AT_?", "AT_MINSIGSTKSZ" };
diff --git a/lib/musl-1.1.18/test-stack-reloc/compile.sh b/lib/musl-1.1.18/test-stack-reloc/compile.sh
new file mode 100755
index 00000000..a9513e3f
--- /dev/null
+++ b/lib/musl-1.1.18/test-stack-reloc/compile.sh
@@ -0,0 +1,3 @@
+#!/bin/sh
+../toolchain_x86-64/bin/musl-gcc -o sd self-dump.c -static -v
+
diff --git a/lib/musl-1.1.18/test-stack-reloc/self-dump.c b/lib/musl-1.1.18/test-stack-reloc/self-dump.c
new file mode 100644
index 00000000..0ef0aded
--- /dev/null
+++ b/lib/musl-1.1.18/test-stack-reloc/self-dump.c
@@ -0,0 +1,172 @@
+
+/* Antonio Barbalace, Stevens 2019 */
+
+/* tested only on 64bit architectures */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <elf.h>
+#include <link.h>
+#include <limits.h>
+#include <stdint.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "auxv.h"
+
+#define BUFFER_SIZE 128
+char buffer[BUFFER_SIZE];
+
+int main (int argc, char * argv[], char * envp[])
+{
+    
+    printf("argc %d &argc 0x%lx argv 0x%lx\n",
+        argc, (unsigned long)&argc, (unsigned long)argv);
+    
+    int i;
+    for (i=0; i< argc; i++)
+        printf("argv %d at 0x%lx %s\n",
+            i, (unsigned long)argv[i], argv[i]);
+    
+    printf("\nenvp 0x%lx\n", (unsigned long) envp);
+    i=0;
+    while (envp[i++] != 0)
+        printf("envp %d at 0x%lx %s\n",
+               i-1, (unsigned long)envp[i-1], envp[i-1]);
+    
+    Elf64_Phdr* phdr=0; Elf64_Ehdr* sysinfo_ehdr=0;
+    long phent=0; long phnum=0;
+    Elf64_auxv_t *auxv = (Elf64_auxv_t *)&envp[i];
+    printf("\nauxv 0x%lx sizeof(Elf64_auxv_t) %d\n",
+           (unsigned long) auxv, (int)sizeof(Elf64_auxv_t));
+    for (auxv = (Elf64_auxv_t *)&envp[i]; auxv->a_type != AT_NULL; auxv++)
+        switch (auxv->a_type) {
+			case AT_SYSINFO_EHDR:
+				sysinfo_ehdr = (void*)auxv->a_un.a_val;
+				break;
+            case AT_PLATFORM:
+            case AT_BASE_PLATFORM:
+            case AT_EXECFN:
+                printf("%s (%d) value %s (0x%lx)\n",
+                       at_desc[(int)auxv->a_type], (int)auxv->a_type, (char*)auxv->a_un.a_val, auxv->a_un.a_val);
+                break;
+            case AT_PHDR:
+                phdr = (void*)auxv->a_un.a_val;
+                break;
+            case AT_PHENT:
+                phent = auxv->a_un.a_val;
+                break;
+            case AT_PHNUM:
+                phnum = auxv->a_un.a_val;
+                break;
+            default:
+                printf("%s (%d) value 0x%lx\n",
+                       at_desc[(int)auxv->a_type], (int)auxv->a_type, auxv->a_un.a_val);
+        };
+
+    printf("\n");
+    printf("phdr 0x%lx phent %d (%d) phnum %d\n",
+        (unsigned long)phdr, (int)phent, (int)sizeof(Elf64_Phdr), (int)phnum);
+    for (i=0; i< phnum; i++) {
+        printf("i: %d type: %d flags: %d off: 0x%lx vaddr: 0x%lx paddr: 0x%lx filesz: 0x%lx memsz: 0x%lx align: 0x%lx\n",
+                   i, phdr[i].p_type, phdr[i].p_flags, phdr[i].p_offset, phdr[i].p_vaddr, phdr[i].p_paddr,
+                   phdr[i].p_filesz, phdr[i].p_memsz, phdr[i].p_align);
+    }
+
+    if (!sysinfo_ehdr)
+		return 0;
+    printf("\n");
+    printf("sysinfo_ehdr 0x%lx ident %s type %x machine %x version %x entry 0x%lx "
+		   "poff %lx soff %lx ehsize %x phentsize %x phnum %d shentsize %x shnum %d shstrndx %d\n",
+		   (unsigned long)sysinfo_ehdr, sysinfo_ehdr->e_ident, sysinfo_ehdr->e_type, sysinfo_ehdr->e_machine, 
+		   sysinfo_ehdr->e_version, sysinfo_ehdr->e_entry, 
+		   sysinfo_ehdr->e_phoff, sysinfo_ehdr->e_shoff,
+		   sysinfo_ehdr->e_ehsize, sysinfo_ehdr->e_phentsize, sysinfo_ehdr->e_phnum, sysinfo_ehdr->e_shentsize,
+		   sysinfo_ehdr->e_shnum, sysinfo_ehdr->e_shstrndx);
+    
+	Elf64_Phdr *ph = (void *)((char *)sysinfo_ehdr + sysinfo_ehdr->e_phoff);
+	size_t *dynv=0, base=-1;
+	for (i=0; i<sysinfo_ehdr->e_phnum; i++, ph=(void *)((char *)ph+sysinfo_ehdr->e_phentsize)) {
+        printf("i: %d type: %d flags: %d off: 0x%lx vaddr: 0x%lx paddr: 0x%lx filesz: 0x%lx memsz: 0x%lx align: 0x%lx\n",
+                   i, ph->p_type, ph->p_flags, ph->p_offset, ph->p_vaddr, ph->p_paddr,
+                   ph->p_filesz, ph->p_memsz, ph->p_align);
+		if (ph->p_type == PT_LOAD)
+			base = (size_t)sysinfo_ehdr + ph->p_offset - ph->p_vaddr;
+		else if (ph->p_type == PT_DYNAMIC)
+			dynv = (void *)((char *)sysinfo_ehdr + ph->p_offset);
+	}
+	printf("dynv 0x%lx base 0x%lx\n", (unsigned long) dynv, (unsigned long)base);
+     
+	char *strings = 0;
+	Elf64_Sym *syms = 0;
+	Elf_Symndx *hashtab = 0;
+	uint16_t *versym = 0;
+	Elf64_Verdef *verdef = 0;
+	
+	for (i=0; dynv[i]; i+=2) {
+		void *p = (void *)(base + dynv[i+1]);
+		switch(dynv[i]) {
+		case DT_STRTAB: strings = p; break;
+		case DT_SYMTAB: syms = p; break;
+		case DT_HASH: hashtab = p; break;
+		case DT_VERSYM: versym = p; break;
+		case DT_VERDEF: verdef = p; break;
+		}
+		printf("dynv %d DT_ %ld @ 0x%lx\n", i, dynv[i], (unsigned long) p);
+	}	
+
+	
+		printf("\n VDSO dynamic symbols \n"); /* print dynamic symbols */
+	for (i=0; i<hashtab[1]; i++) {
+		printf("I %d sym %s section %d value %lx size %ld\n", 
+			   i, strings+syms[i].st_name, syms[i].st_shndx, syms[i].st_value, syms[i].st_size);
+	}
+
+	printf("\n VDSO sections \n");
+	Elf64_Sym *sh_syms = 0;
+	Elf_Symndx *sh_hashtab = 0;
+	Elf64_Shdr *sh = (void *)((char *)sysinfo_ehdr + sysinfo_ehdr->e_shoff);
+	char *sh_strings = base + (unsigned long)((Elf64_Shdr *)((char*)sh + ((sysinfo_ehdr->e_shentsize) * sysinfo_ehdr->e_shstrndx)))->sh_offset;
+	
+	for (i=0; i<sysinfo_ehdr->e_shnum; i++, sh=(void *)((char *)sh+sysinfo_ehdr->e_shentsize)) {
+		//if (sh->sh_type == SHT_STRTAB && sh->sh_addr != 0)
+		//	sh_strings = (char*) sh->sh_addr + (unsigned long)base ;
+		if (sh->sh_type == SHT_DYNSYM)
+			sh_syms = (void*) sh->sh_addr + (unsigned long)base ;
+		if (sh->sh_type == SHT_HASH)
+			sh_hashtab = (void*) sh->sh_addr + (unsigned long)base ;
+
+        printf("i: %d name: %d (%s) type: %d flags: 0x%lx addr: 0x%lx offset: 0x%lx size: 0x%lx addralign: 0x%lx entsize: 0x%lx\n",
+                   i, sh->sh_name, sh_strings? sh_strings + sh->sh_name : 0, sh->sh_type, sh->sh_flags, sh->sh_addr, sh->sh_offset,
+                   sh->sh_size, sh->sh_addralign, sh->sh_entsize);
+	}
+	
+	printf(" strings @ 0x%lx, sh_strings @ 0x%lx syms 0x%lx hashtab 0x%lx\n", (unsigned long )strings, (unsigned long )sh_strings, (unsigned long) sh_syms, (unsigned long) sh_hashtab); // they are at the same address -- duplicated information
+
+	
+	
+/* Note that the [vvar] section in x86_64 and aarch64 comes right before the [vdso] section, in aarch64 is 1 page up to 5.15 and in x86_64 is 3 pages up to 5.15 -- it has no headers */
+// https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/vdso/vdso-layout.lds.S
+// https://elixir.bootlin.com/linux/latest/source/arch/arm64/kernel/vdso/vdso.lds.S
+
+//https://elixir.bootlin.com/linux/latest/source/arch/arm64/kernel/vdso.c
+//https://elixir.bootlin.com/linux/latest/source/arch/x86/entry/vdso/vma.c
+
+/* it seems like they strip the symtab section away in order to have vvar, really strange but we cannot do anything about it! */
+	
+	printf("\n");
+	int fd = open("/proc/self/maps", O_RDONLY);
+	do {
+		memset(buffer, 0, BUFFER_SIZE);
+		i = read(fd, buffer, BUFFER_SIZE);
+		printf("%s", buffer);}
+	while(i);
+        
+    sleep(30);
+        
+    return 0;
+}
diff --git a/lib/musl-1.1.18/test-stack-reloc/test_memcpy_nostack_x86.c b/lib/musl-1.1.18/test-stack-reloc/test_memcpy_nostack_x86.c
new file mode 100644
index 00000000..618214fa
--- /dev/null
+++ b/lib/musl-1.1.18/test-stack-reloc/test_memcpy_nostack_x86.c
@@ -0,0 +1,77 @@
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <sys/mman.h>
+
+#define __memcpy_nostack(dest, src, n) \
+	({ unsigned long retval =-1; \
+	__asm__ volatile(".weak __memcpy_nostack \n" \
+		".weak __memcpy_nostack_exit \n" \
+		".weak __memcpy_nostack_copy \n" \
+		"__memcpy_nostack:" \
+		"cmp %4, %3; \n\t" \
+		"jg __memcpy_nostack_exit; \n" \
+		"movq %1, %%r8; \n\t" \
+		"cmp %%r8, %2; \n\t" \
+		"jle __memcpy_nostack_exit; \n" \
+		"__memcpy_nostack_copy:" \
+		"movb (%4, %%r8, 1), %%r9b; \n\t" \
+		"movb %%r9b, (%3, %%r8, 1); \n\t" \
+		"inc %%r8; \n\t" \
+		"cmp %%r8, %2; \n\t" \
+		"jg __memcpy_nostack_copy; \n" \
+		"__memcpy_nostack_exit:" \
+		"movq %%r8, %0; \n\t" \
+		: "=r" (retval) \
+		: "I" (0), "r" (n), \
+		  "r" (dest), "r" (src) \
+		: "r9b", "r8", "memory"); \
+	retval; })
+
+
+int main()
+{
+	int N = 4096;
+	void *old_addr = (void *)0x7fffffff1000;
+	int *ptr = mmap(old_addr, N * sizeof(int), 
+			PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0 );
+
+	if (ptr == MAP_FAILED) {
+		printf("Mapping Failed\n");
+		return 1;
+	}
+	printf("old_addr is : %p \n", old_addr);
+	printf("ptr is : %p \n", ptr);
+
+	for(int i=0; i<N; i++)
+		ptr[i] = i;
+
+	for(int i=0; i<N; i += 512)
+		printf("%4d ", ptr[i]);
+	printf("\n");
+
+	void *new_addr = (void*)((long int)ptr - 0x000000001000);
+
+	int *new_ptr = mmap(new_addr, N * sizeof(int), 
+			PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0 );
+	printf("new_addr is : %p \n", new_addr);
+	printf("new_ptr is : %p \n", new_ptr);
+
+	for(int i=0; i<N; i++)
+		new_ptr[i] = 2 * i;
+
+	for(int i=0; i<N; i += 512)
+		printf("%4d ", ptr[i]);
+	printf("\n");
+
+	for(int i=0; i<N; i += 512)
+		printf("%4d ", new_ptr[i]);
+	printf("\n");
+
+	long int result = __memcpy_nostack(new_ptr, ptr, (long int)(4 * N));
+	printf("Result is: %ld\n", result);
+
+	for(int i=0; i<N; i += 512)
+		printf("%4d ", new_ptr[i]);
+	printf("\n");
+}
+
